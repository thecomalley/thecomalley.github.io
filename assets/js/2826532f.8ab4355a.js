"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([[949],{3917:e=>{e.exports=JSON.parse('{"permalink":"/terraform-azurerm-python-function","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-04-06/index.md","source":"@site/blog/2025-04-06/index.md","title":"Deploying Python Function Apps to Azure with Terraform","description":"A number of the workloads I run in Azure are based around Python Function Apps. I thought it would be a good idea to create a Terraform module that can be reused across multiple projects while leveraging out some of the newer features in Terraform: Terraform Test framework and Write-only arguments.","date":"2025-04-06T00:00:00.000Z","tags":[{"inline":true,"label":"terraform","permalink":"/tags/terraform"},{"inline":true,"label":"azure","permalink":"/tags/azure"},{"inline":true,"label":"python","permalink":"/tags/python"},{"inline":true,"label":"function-app","permalink":"/tags/function-app"},{"inline":true,"label":"devops","permalink":"/tags/devops"}],"readingTime":5.945,"hasTruncateMarker":true,"authors":[{"name":"Chris O\'Malley","title":"Senior DevOps Engineer","page":{"permalink":"/authors/chris-omalley/"},"socials":{"linkedin":"https://www.linkedin.com/in/thecomalley/","github":"https://github.com/thecomalley"},"imageURL":"https://avatars.githubusercontent.com/u/31399219?v=4","key":"chris"}],"frontMatter":{"slug":"terraform-azurerm-python-function","title":"Deploying Python Function Apps to Azure with Terraform","authors":["chris"],"tags":["terraform","azure","python","function-app","devops"]},"unlisted":false,"nextItem":{"title":"AI Pull Request Descriptions in Azure DevOps","permalink":"/ai-pr-descriptions-in-azure-devops"}}')},6568:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>u});var r=n(3917),s=n(4848),o=n(8453);const a={slug:"terraform-azurerm-python-function",title:"Deploying Python Function Apps to Azure with Terraform",authors:["chris"],tags:["terraform","azure","python","function-app","devops"]},i=void 0,l={authorsImageUrls:[void 0]},u=[{value:"Module Overview",id:"module-overview",level:2},{value:"Function Source Code Deployment",id:"function-source-code-deployment",level:2},{value:"Terraform Test",id:"terraform-test",level:2},{value:"Provider",id:"provider",level:3},{value:"Setup Module",id:"setup-module",level:3},{value:"Main Module",id:"main-module",level:3},{value:"HTTP Tests",id:"http-tests",level:3},{value:"Secrets Management",id:"secrets-management",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["A number of the workloads I run in Azure are based around Python Function Apps. I thought it would be a good idea to create a Terraform module that can be reused across multiple projects while leveraging out some of the newer features in Terraform: ",(0,s.jsx)(t.a,{href:"https://developer.hashicorp.com/terraform/language/tests",children:"Terraform Test framework"})," and ",(0,s.jsx)(t.a,{href:"https://developer.hashicorp.com/terraform/language/resources/ephemeral/write-only",children:"Write-only arguments"}),"."]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://github.com/thecomalley/terraform-azurerm-python-function",children:"View the Module on GitHub"})}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"module-overview",children:"Module Overview"}),"\n",(0,s.jsx)(t.p,{children:"The module deploys a Python Function App along with its source code to Azure. It creates the necessary resources such as a resource group, storage account, service plan, application insights, log analytics workspace, and key vault. The module also handles the deployment of the Python source code and sets up environment variables."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:n(6724).A+"",width:"1824",height:"848"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-hcl",children:'# example module call\nmodule "terraform_azurerm_python_function" {\n  source  = "thecomalley/python-function/azurerm"\n  version = "1.1.0"\n\n  location = "Australia East"\n\n  resource_group_name       = "example-rg"\n  function_app_name         = "example-func"\n  storage_account_name      = "examplestorage"\n  log_analytics_name        = "example-law"\n  app_service_plan_name     = "example-asp"\n  application_insights_name = "example-ai"\n  key_vault_name            = "example-kv"\n\n  python_version     = "3.11"\n  python_source_code = "src"\n\n  environment_variables = {\n    EXAMPLE_ENV_1 = "value1"\n    EXAMPLE_ENV_2 = "value2"\n  }\n\n  secret_environment_variables = [\n    "SECRET_1",\n    "SECRET_2",\n  ]\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"function-source-code-deployment",children:"Function Source Code Deployment"}),"\n",(0,s.jsx)(t.p,{children:"This module leverages the Zip deploy method to deploy the source code to Azure. This is ideal for small projects or when you want to keep the source code in the same repository as your Terraform code."}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsxs)(t.p,{children:["For larger projects separating infrastructure and source code deployment might be more appropriate. You can read more about the different deployment methods ",(0,s.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/azure/azure-functions/functions-deployment-technologies?tabs=windows",children:"here"}),"."]})}),"\n",(0,s.jsxs)(t.p,{children:["We are able to create a Zip file using the ",(0,s.jsx)(t.code,{children:"archive_file"})," resource in terraform, this is a pretty common pattern often used for deploying Lambda functions to AWS"]}),"\n",(0,s.jsx)(t.p,{children:"We need to set a few app settings to enable this to work on the Function App however,"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"ENABLE_ORYX_BUILD"}),": Indicates whether the Oryx build system is used during deployment. This must be set to ",(0,s.jsx)(t.code,{children:"true"})," when performing remote build deployments to Linux."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"SCM_DO_BUILD_DURING_DEPLOYMENT"}),": Controls remote build behavior during deployment. When set to ",(0,s.jsx)(t.code,{children:"true"}),", the project is built remotely during deployment."]}),"\n",(0,s.jsxs)(t.li,{children:["Finally we pass the path to the zip file ",(0,s.jsx)(t.code,{children:"zip_deploy_file"})]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"terraform-test",children:"Terraform Test"}),"\n",(0,s.jsxs)(t.p,{children:["This module also makes use of the ",(0,s.jsx)(t.a,{href:"https://developer.hashicorp.com/terraform/language/tests",children:"Terraform Test"})," functionality introduced in Terraform v1.6.0. Let's walk through how it all works."]}),"\n",(0,s.jsxs)(t.p,{children:["We create a test file called ",(0,s.jsx)(t.code,{children:"main.tftest.hcl"})," under the ",(0,s.jsx)(t.code,{children:"tests"})," directory."]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["Each Terraform test lives in a test file. Terraform discovers test files are based on their file extension: ",(0,s.jsx)(t.code,{children:".tftest.hcl"})," or ",(0,s.jsx)(t.code,{children:".tftest.json."})]})}),"\n",(0,s.jsx)(t.h3,{id:"provider",children:"Provider"}),"\n",(0,s.jsxs)(t.p,{children:["We define our provider the same way we would in our main module. Since azurerm v4, the ",(0,s.jsx)(t.code,{children:"subscription_id"})," is a required field, but we can set it via the ",(0,s.jsx)(t.code,{children:"ARM_SUBSCRIPTION_ID"})," environment variable, I've added a comment to remind me to do so!"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ruby",children:'# tests/main.tftest.hcl\nprovider "azurerm" {\n  features {}\n  # ARM_SUBSCRIPTION_ID = ""\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"setup-module",children:"Setup Module"}),"\n",(0,s.jsx)(t.p,{children:"Often, modules depend on pre-existing infrastructure. A common pattern is to deploy this infrastructure in a setup module before running the test. While this module doesn't require any prerequisites, I still include a setup module to create a random ID for the test run. This helps in generating unique resource names and avoiding name collisions."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ruby",children:'# tests/main.tftest.hcl\nrun "setup" {\n  module {\n    source = "./tests/setup"\n  }\n}\n\n# tests/setup/main.tf\nresource "random_id" "test" {\n  byte_length = 4\n}\n\noutput "test_id" {\n  value = random_id.test.hex\n}\n\noutput "module_name" {\n  value = basename(path.cwd)\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"main-module",children:"Main Module"}),"\n",(0,s.jsx)(t.p,{children:"Now its time for the main test run. We are deploying the module passing in some required variables. I've also included the starter code for a Function App, this way we can ensure the module deploys successfully."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ruby",children:'run "main" {\n  variables {\n    resource_group_name       = "tapf-test${run.setup.test_id}-rg"\n    function_app_name         = "tapf-test${run.setup.test_id}-func"\n    storage_account_name      = "tapftest${run.setup.test_id}storage"\n    log_analytics_name        = "tapf-test${run.setup.test_id}-law"\n    app_service_plan_name     = "tapf-test${run.setup.test_id}-asp"\n    application_insights_name = "tapf-test${run.setup.test_id}-ai"\n    key_vault_name            = "tapf-test${run.setup.test_id}-kv"\n\n    python_version     = "3.11"\n    python_source_code = "src"\n  }\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"http-tests",children:"HTTP Tests"}),"\n",(0,s.jsxs)(t.p,{children:["Now that we have confirmed the module has successfully deployed we are going to create one more helper module to verify that the function app is running and responding to requests. The helper module will use the ",(0,s.jsx)(t.code,{children:"http"})," data source to make a request to the function app and access its response."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ruby",children:'# tests/http/main.tf\nvariable "endpoint" {\n  type = string\n}\n\nvariable "function_app_name" {\n  type = string\n}\n\nvariable "resource_group_name" {\n  type = string\n}\n\ndata "azurerm_function_app_host_keys" "test" {\n  name                = var.function_app_name\n  resource_group_name = var.resource_group_name\n}\n\ndata "http" "test" {\n  url    = "https://${var.endpoint}/api/req?code=${data.azurerm_function_app_host_keys.test.primary_key}&user=terraform"\n  method = "GET"\n\n  request_headers = {\n    "Accept" = "application/json"\n  }\n\n  request_body = jsonencode({\n    "user" = "terraform"\n  })\n}\n\noutput "body" {\n  value = data.http.test.body\n}\n\noutput "status_code" {\n  value = data.http.test.status_code\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["This test uses the final helper module and references the ",(0,s.jsx)(t.code,{children:"function_app_name"}),", ",(0,s.jsx)(t.code,{children:"default_hostname"})," & ",(0,s.jsx)(t.code,{children:"resource_group_name"})," outputs from the main module for so the helper can get the ",(0,s.jsx)(t.code,{children:"azurerm_function_app_host_keys"})," and make an HTTP request. It also defines two assert blocks to"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"check that the HTTP GET request responds with a 200 status code, indicating that the website is running properly."}),"\n",(0,s.jsxs)(t.li,{children:["check that the HTTP response body is ",(0,s.jsx)(t.code,{children:"Hello, terraform!"})," indicating that our test source code has successfully deployed and is running"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-hcl",children:'# tests/main.tftest.hcl\nrun "source_code_deployed" {\n  command = plan\n\n  module {\n    source = "./tests/http"\n  }\n\n  variables {\n    function_app_name   = run.main.function_app_name\n    resource_group_name = run.main.resource_group_name\n    endpoint            = run.main.default_hostname\n  }\n\n  assert {\n    condition     = data.http.test.status_code == 200\n    error_message = "Website responded with HTTP status ${data.http.test.status_code}"\n  }\n  assert {\n    condition     = data.http.test.body == "Hello, terraform!"\n    error_message = "Website responded with body ${data.http.test.body}"\n  }\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"secrets-management",children:"Secrets Management"}),"\n",(0,s.jsx)(t.p,{children:"HashiCorp recently introduced write-only arguments and ephemeral resources to enhance secret management. This module leverages these features."}),"\n",(0,s.jsx)(t.p,{children:"Previously, creating a secret in the Key Vault would also store its value in the Terraform state file, exposing it in plaintext and duplicating it in two locations. This was not ideal for sensitive data."}),"\n",(0,s.jsxs)(t.p,{children:["Even adding a lifecycle ignore_changes block wouldn't get around this issue, while it would allow the user to update the value in the portal independent of terraform running a ",(0,s.jsx)(t.code,{children:"terraform plan"})," would still refresh the actual secret value into the state file"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-hcl",children:"lifecycle {\n  ignore_changes = [value] # Allow the value to be managed in the portal\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["With AzureRM v4.23.0, the ",(0,s.jsx)(t.code,{children:"value_wo"})," argument in the ",(0,s.jsx)(t.code,{children:"azurerm_key_vault_secret"})," resource allows secrets to be created in the Key Vault without saving their values in the state file. This is particularly useful for secrets managed outside of Terraform, such as passwords or API keys."]}),"\n",(0,s.jsxs)(t.p,{children:["This module pre-creates the required secrets and links them to the function app using ",(0,s.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/azure/app-service/app-service-key-vault-references?tabs=azure-cli",children:"Key Vault references"}),". However, it leaves the responsibility of setting the secret values to the user."]}),"\n",(0,s.jsx)(t.p,{children:"This approach leaves us with a Function app that is ready to go all the user needs to do is update the value of any secrets in the KeyVault"}),"\n",(0,s.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(t.p,{children:"So there we have it\u2014a simple module to deploy a Python Function App to Azure. I'll be leveraging this module in several projects in the future."}),"\n",(0,s.jsxs)(t.p,{children:["If you found this module useful, please consider ",(0,s.jsx)(t.a,{href:"https://github.com/thecomalley/terraform-azurerm-python-function",children:"giving it a star on GitHub"}),". If you have any questions or suggestions, feel free to open an issue or submit a pull request. Your feedback is always welcome!"]})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},6724:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/tapf-test-rg-7ea7f1ee888328ef7bd951edc0fbe13b.png"},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var r=n(6540);const s={},o=r.createContext(s);function a(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);